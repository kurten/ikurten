<p>上个星期，因为项目需要，学习了一下<a href="http://memcachedb.org/memcacheq/" target="_blank">memcacheq</a>（一个持久化的消息队列），同时，写了一个定制性质的client（当然，协议还是用<a href="http://memcached.org/" target="_blank">memcached</a>的）。由于自身业务上面的需要，把这个client折腾成了可以根据配置进行扩展的方式。主要是针对业务处理消息的方法。</p>

<p>单纯的<a href="http://memcachedb.org/memcacheq/" target="_blank">memcacheq</a>、<a href="http://memcachedb.org/" target="_blank">memcachedb</a>、<a href="http://memcached.org/" target="_blank">memcached</a>其实都没有集群的能力，只是用于单机的。如果没有客户端，那么也算不得一个完整的东西。原先的client采用连接池的方式，用来继承扩展还是太过麻烦，于是就自己写了一个socket连接。连接协议摆在那，自己写一个还是相对轻松很多的。各个业务以及一个queue连接，采用线程的处理方式。这样的话，就需要对线程进行定时检查，防止线程处理过程中索死或者interrupted，这主要还是为了容错。</p>

<p>这次的后台架构，主要还是为了替换掉原先的基于xmpp的消息通信方式，消息丢失么，这是最讨厌的。虽然，我们的业务对于并发没有很高的要求，但是丢失这个问题，还是比较严重的，xmpp没有消息回执，所以时常会导致消息丢失。同时，它的clustering插件也太过于恶心，后续还是会被弃用的。</p>

<p>这星期么，去测试一下<a href="http://memcachedb.org/memcacheq/" target="_blank">memcacheq</a>多队列单机的性能，同时，深入学习一下<a href="http://memcachedb.org/memcacheq/" target="_blank">memcacheq</a>的源代码。阅读源代码确实可以学习到很多东西。特别是别人的逻辑，思路。</p>
