
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>ikurten.com</title>
  <meta name="author" content="kurten">

  
  <meta name="description" content="越来越觉着大学里学的谭浩强的《C语言程序设计》太狗血了，哎，悔不当初啊。 今天下午闲着看了一下memcacheq这个消息队列的源代码，存储引擎用得bdb，bdb支持队列方式的数据存储，只不过一个record必须fixed-length，具体能存多大的长度，我没再官方的doc中找到，不过， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ikurten.com/blog/page/3/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="ikurten.com" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">ikurten.com</a></h1>
  
    <h2>85后码农.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:ikurten.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/about/">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/12/04/%E9%98%85%E8%AF%BBmemcacheq%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95/">阅读memcacheq源码记录</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-04T12:07:34+08:00" pubdate data-updated="true">2011-12-04</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>越来越觉着大学里学的谭浩强的《C语言程序设计》太狗血了，哎，悔不当初啊。</p>

<p>今天下午闲着看了一下<a href="http://memcachedb.org/memcacheq/">memcacheq</a>这个消息队列的源代码，存储引擎用得<a href="http://www.oracle.com/technetwork/database/berkeleydb/overview/index.html">bdb</a>，<a href="http://www.oracle.com/technetwork/database/berkeleydb/overview/index.html">bdb</a>支持队列方式的数据存储，只不过一个record必须fixed-length，具体能存多大的长度，我没再官方的doc中找到，不过，<a href="http://memcachedb.org/memcacheq/">memcacheq</a>作者说最大消息长度不能超过64K，而且，如果你超过了64K，消息队列就挂了，嗯，这个我碰到过了，超过64K，存入消息队列之后，整个消息队列就得重启。所以，如果你不确定以后业务变更会增加消息体的大小，那么我不建议你使用<a href="http://memcachedb.org/memcacheq/">memcacheq</a> :) 。</p>

<p><a href="http://memcachedb.org/memcacheq/">memcacheq</a>在内存里维护一个队列的hash，memcacheq.c文件实现了memcached协议，bdb.c文件实现了对于bdb的读写，发觉消息队列持久化用bdb实现实在是很轻量、很简洁，item.c对协议层的封装，操作结构体item。</p>

<p>用<a href="http://libevent.org/">libevent</a>对收到的通信包做callback，包括对bdb做增、删、存操作。bdb也用<a href="http://libevent.org/">libevent</a>，对<a href="http://libevent.org/">libevent</a>没有研究，略过N字 :)。</p>

<p>ps&nbsp;<a href="http://memcachedb.org/memcacheq/">memcacheq</a>测试使用的是python写的memcache.py。</p>

<p>简单，有效的持久化消息队列，性能过得去，抽空我得好好看看C语言，学习一下 :) 复习一下数据结构，以前的早忘记了，而且也没怎么好好学。老外写的<a href="http://book.douban.com/subject/1139336/">《C语言程序设计》</a>这本，不错的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/27/memcached-protocol/">Memcached Protocol</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-27T05:56:29+08:00" pubdate data-updated="true">2011-11-27</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Protocol</p>

<hr />

<p>Clients of memcached communicate with server through TCP connections.</p>

<p>(A UDP interface is also available; details are below under &#8220;UDP</p>

<p>protocol.&#8221;) A given running memcached server listens on some</p>

<p>(configurable) port; clients connect to that port, send commands to</p>

<p>the server, read responses, and eventually close the connection.</p>

<p>There is no need to send any command to end the session. A client may</p>

<p>just close the connection at any moment it no longer needs it. Note,</p>

<p>however, that clients are encouraged to cache their connections rather</p>

<p>than reopen them every time they need to store or retrieve data.&nbsp; This</p>

<p>is because memcached is especially designed to work very efficiently</p>

<p>with a very large number (many hundreds, more than a thousand if</p>

<p>necessary) of open connections. Caching connections will eliminate the</p>

<p>overhead associated with establishing a TCP connection (the overhead</p>

<p>of preparing for a new connection on the server side is insignificant</p>

<p>compared to this).</p>

<p>There are two kinds of data sent in the memcache protocol: text lines</p>

<p>and unstructured data.&nbsp; Text lines are used for commands from clients</p>

<p>and responses from servers. Unstructured data is sent when a client</p>

<p>wants to store or retrieve data. The server will transmit back</p>

<p>unstructured data in exactly the same way it received it, as a byte</p>

<p>stream. The server doesn&#8217;t care about byte order issues in</p>

<p>unstructured data and isn&#8217;t aware of them. There are no limitations on</p>

<p>characters that may appear in unstructured data; however, the reader</p>

<p>of such data (either a client or a server) will always know, from a</p>

<p>preceding text line, the exact length of the data block being</p>

<p>transmitted.</p>

<p>Text lines are always terminated by \r\n. Unstructured data is <em>also</em></p>

<p>terminated by \r\n, even though \r, \n or any other 8-bit characters</p>

<p>may also appear inside the data. Therefore, when a client retrieves</p>

<p>data from a server, it must use the length of the data block (which it</p>

<p>will be provided with) to determine where the data block ends, and not</p>

<p>the fact that \r\n follows the end of the data block, even though it</p>

<p>does.</p>

<p>Keys</p>

<hr />

<p>Data stored by memcached is identified with the help of a key. A key</p>

<p>is a text string which should uniquely identify the data for clients</p>

<p>that are interested in storing and retrieving it.&nbsp; Currently the</p>

<p>length limit of a key is set at 250 characters (of course, normally</p>

<p>clients wouldn&#8217;t need to use such long keys); the key must not include</p>

<p>control characters or whitespace.</p>

<p>Commands</p>

<hr />

<p>There are three types of commands.</p>

<p>Storage commands (there are six: &#8220;set&#8221;, &#8220;add&#8221;, &#8220;replace&#8221;, &#8220;append&#8221;</p>

<p>&#8220;prepend&#8221; and &#8220;cas&#8221;) ask the server to store some data identified by a key. The</p>

<p>client sends a command line, and then a data block; after that the</p>

<p>client expects one line of response, which will indicate success or</p>

<p>faulure.</p>

<p>Retrieval commands (there are two: &#8220;get&#8221; and &#8220;gets&#8221;) ask the server to</p>

<p>retrieve data corresponding to a set of keys (one or more keys in one</p>

<p>request). The client sends a command line, which includes all the</p>

<p>requested keys; after that for each item the server finds it sends to</p>

<p>the client one response line with information about the item, and one</p>

<p>data block with the item&#8217;s data; this continues until the server</p>

<p>finished with the &#8220;END&#8221; response line.</p>

<p>All other commands don&#8217;t involve unstructured data. In all of them,</p>

<p>the client sends one command line, and expects (depending on the</p>

<p>command) either one line of response, or several lines of response</p>

<p>ending with &#8220;END&#8221; on the last line.</p>

<p>A command line always starts with the name of the command, followed by</p>

<p>parameters (if any) delimited by whitespace. Command names are</p>

<p>lower-case and are case-sensitive.</p>

<p>Expiration times</p>

<hr />

<p>Some commands involve a client sending some kind of expiration time</p>

<p>(relative to an item or to an operation requested by the client) to</p>

<p>the server. In all such cases, the actual value sent may either be</p>

<p>Unix time (number of seconds since January 1, 1970, as a 32-bit</p>

<p>value), or a number of seconds starting from current time. In the</p>

<p>latter case, this number of seconds may not exceed 60<em>60</em>24*30 (number</p>

<p>of seconds in 30 days); if the number sent by a client is larger than</p>

<p>that, the server will consider it to be real Unix time value rather</p>

<p>than an offset from current time.</p>

<p>Error strings</p>

<hr />

<p>Each command sent by a client may be answered with an error string</p>

<p>from the server. These error strings come in three types:</p>

<ul>
<li>&#8220;ERROR\r\n&#8221;</li>
</ul>


<p>means the client sent a nonexistent command name.</p>

<ul>
<li>&#8220;CLIENT_ERROR <error>\r\n&#8221;</li>
</ul>


<p>means some sort of client error in the input line, i.e. the input</p>

<p>doesn&#8217;t conform to the protocol in some way. <error> is a</p>

<p>human-readable error string.</p>

<ul>
<li>&#8220;SERVER_ERROR <error>\r\n&#8221;</li>
</ul>


<p>means some sort of server error prevents the server from carrying</p>

<p>out the command. <error> is a human-readable error string. In cases</p>

<p>of severe server errors, which make it impossible to continue</p>

<p>serving the client (this shouldn&#8217;t normally happen), the server will</p>

<p>close the connection after sending the error line. This is the only</p>

<p>case in which the server closes a connection to a client.</p>

<p>In the descriptions of individual commands below, these error lines</p>

<p>are not again specifically mentioned, but clients must allow for their</p>

<p>possibility.</p>

<p>Storage commands</p>

<hr />

<p>First, the client sends a command line which looks like this:</p>

<p><command name> <key> <flags> <exptime> <bytes> [noreply]\r\n</p>

<p>cas <key> <flags> <exptime> <bytes> <cas unqiue> [noreply]\r\n</p>

<ul>
<li><command name> is &#8220;set&#8221;, &#8220;add&#8221;, &#8220;replace&#8221;, &#8220;append&#8221; or &#8220;prepend&#8221;</li>
</ul>


<p>&#8220;set&#8221; means &#8220;store this data&#8221;.</p>

<p>&#8220;add&#8221; means &#8220;store this data, but only if the server <em>doesn&#8217;t</em> already</p>

<p>hold data for this key&#8221;.</p>

<p>&#8220;replace&#8221; means &#8220;store this data, but only if the server <em>does</em></p>

<p>already hold data for this key&#8221;.</p>

<p>&#8220;append&#8221; means &#8220;add this data to an existing key after existing data&#8221;.</p>

<p>&#8220;prepend&#8221; means &#8220;add this data to an existing key before existing data&#8221;.</p>

<p>The append and prepend commands do not accept flags or exptime.</p>

<p>They update existing data portions, and ignore new flag and exptime</p>

<p>settings.</p>

<p>&#8220;cas&#8221; is a check and set operation which means &#8220;store this data but</p>

<p>only if no one else has updated since I last fetched it.&#8221;</p>

<ul>
<li><p><key> is the key under which the client asks to store the data</p></li>
<li><p><flags> is an arbitrary 16-bit unsigned integer (written out in</p></li>
</ul>


<p>decimal) that the server stores along with the data and sends back</p>

<p>when the item is retrieved. Clients may use this as a bit field to</p>

<p>store data-specific information; this field is opaque to the server.</p>

<p>Note that in memcached 1.2.1 and higher, flags may be 32-bits, instead</p>

<p>of 16, but you might want to restrict yourself to 16 bits for</p>

<p>compatibility with older versions.</p>

<ul>
<li><exptime> is expiration time. If it&#8217;s 0, the item never expires</li>
</ul>


<p>(although it may be deleted from the cache to make place for other</p>

<p>items). If it&#8217;s non-zero (either Unix time or offset in seconds from</p>

<p>current time), it is guaranteed that clients will not be able to</p>

<p>retrieve this item after the expiration time arrives (measured by</p>

<p>server time).</p>

<ul>
<li><bytes> is the number of bytes in the data block to follow, <em>not</em></li>
</ul>


<p>including the delimiting \r\n. <bytes> may be zero (in which case</p>

<p>it&#8217;s followed by an empty data block).</p>

<ul>
<li><cas unique> is a unique 64-bit value of an existing entry.</li>
</ul>


<p>Clients should use the value returned from the &#8220;gets&#8221; command</p>

<p>when issuing &#8220;cas&#8221; updates.</p>

<ul>
<li>&#8220;noreply&#8221; optional parameter instructs the server to not send the</li>
</ul>


<p>reply.&nbsp; NOTE: if the request line is malformed, the server can&#8217;t</p>

<p>parse &#8220;noreply&#8221; option reliably.&nbsp; In this case it may send the error</p>

<p>to the client, and not reading it on the client side will break</p>

<p>things.&nbsp; Client should construct only valid requests.</p>

<p>After this line, the client sends the data block:</p>

<p><data block>\r\n</p>

<ul>
<li><data block> is a chunk of arbitrary 8-bit data of length <bytes></li>
</ul>


<p>from the previous line.</p>

<p>After sending the command line and the data blockm the client awaits</p>

<p>the reply, which may be:</p>

<ul>
<li><p>&#8220;STORED\r\n&#8221;, to indicate success.</p></li>
<li><p>&#8220;NOT_STORED\r\n&#8221; to indicate the data was not stored, but not</p></li>
</ul>


<p>because of an error. This normally means that either that the</p>

<p>condition for an &#8220;add&#8221; or a &#8220;replace&#8221; command wasn&#8217;t met, or that the</p>

<p>item is in a delete queue (see the &#8220;delete&#8221; command below).</p>

<ul>
<li>&#8220;EXISTS\r\n&#8221; to indicate that the item you are trying to store with</li>
</ul>


<p>a &#8220;cas&#8221; command has been modified since you last fetched it.</p>

<ul>
<li>&#8220;NOT_FOUND\r\n&#8221; to indicate that the item you are trying to store</li>
</ul>


<p>with a &#8220;cas&#8221; command did not exist or has been deleted.</p>

<p>Retrieval command:</p>

<hr />

<p>The retrieval commands &#8220;get&#8221; and &#8220;gets&#8221; operates like this:</p>

<p>get <key>*\r\n</p>

<p>gets <key>*\r\n</p>

<ul>
<li><key>* means one or more key strings separated by whitespace.</li>
</ul>


<p>After this command, the client expects zero or more items, each of</p>

<p>which is received as a text line followed by a data block. After all</p>

<p>the items have been transmitted, the server sends the string</p>

<p>&#8220;END\r\n&#8221;</p>

<p>to indicate the end of response.</p>

<p>Each item sent by the server looks like this:</p>

<p>VALUE <key> <flags> <bytes> [<cas unique>]\r\n</p>

<p><data block>\r\n</p>

<ul>
<li><p><key> is the key for the item being sent</p></li>
<li><p><flags> is the flags value set by the storage command</p></li>
<li><p><bytes> is the length of the data block to follow, <em>not</em> including</p></li>
</ul>


<p>its delimiting \r\n</p>

<ul>
<li><cas unique> is a unique 64-bit integer that uniquely identifies</li>
</ul>


<p>this specific item.</p>

<ul>
<li><data block> is the data for this item.</li>
</ul>


<p>If some of the keys appearing in a retrieval request are not sent back</p>

<p>by the server in the item list this means that the server does not</p>

<p>hold items with such keys (because they were never stored, or stored</p>

<p>but deleted to make space for more items, or expired, or explicitly</p>

<p>deleted by a client).</p>

<p>Deletion</p>

<hr />

<p>The command &#8220;delete&#8221; allows for explicit deletion of items:</p>

<p>delete <key> [<time>] [noreply]\r\n</p>

<ul>
<li><p><key> is the key of the item the client wishes the server to delete</p></li>
<li><p><time> is the amount of time in seconds (or Unix time until which)</p></li>
</ul>


<p>the client wishes the server to refuse &#8220;add&#8221; and &#8220;replace&#8221; commands</p>

<p>with this key. For this amount of item, the item is put into a</p>

<p>delete queue, which means that it won&#8217;t possible to retrieve it by</p>

<p>the &#8220;get&#8221; command, but &#8220;add&#8221; and &#8220;replace&#8221; command with this key</p>

<p>will also fail (the &#8220;set&#8221; command will succeed, however). After the</p>

<p>time passes, the item is finally deleted from server memory.</p>

<p>The parameter <time> is optional, and, if absent, defaults to 0</p>

<p>(which means that the item will be deleted immediately and further</p>

<p>storage commands with this key will succeed).</p>

<ul>
<li>&#8220;noreply&#8221; optional parameter instructs the server to not send the</li>
</ul>


<p>reply.&nbsp; See the note in Storage commands regarding malformed</p>

<p>requests.</p>

<p>The response line to this command can be one of:</p>

<ul>
<li><p>&#8220;DELETED\r\n&#8221; to indicate success</p></li>
<li><p>&#8220;NOT_FOUND\r\n&#8221; to indicate that the item with this key was not</p></li>
</ul>


<p>found.</p>

<p>See the &#8220;flush_all&#8221; command below for immediate invalidation</p>

<p>of all existing items.</p>

<p>Increment/Decrement</p>

<hr />

<p>Commands &#8220;incr&#8221; and &#8220;decr&#8221; are used to change data for some item</p>

<p>in-place, incrementing or decrementing it. The data for the item is</p>

<p>treated as decimal representation of a 64-bit unsigned integer. If the</p>

<p>current data value does not conform to such a representation, the</p>

<p>commands behave as if the value were 0. Also, the item must already</p>

<p>exist for incr/decr to work; these commands won&#8217;t pretend that a</p>

<p>non-existent key exists with value 0; instead, they will fail.</p>

<p>The client sends the command line:</p>

<p>incr <key> <value> [noreply]\r\n</p>

<p>or</p>

<p>decr <key> <value> [noreply]\r\n</p>

<ul>
<li><p><key> is the key of the item the client wishes to change</p></li>
<li><p><value> is the amount by which the client wants to increase/decrease</p></li>
</ul>


<p>the item. It is a decimal representation of a 64-bit unsigned integer.</p>

<ul>
<li>&#8220;noreply&#8221; optional parameter instructs the server to not send the</li>
</ul>


<p>reply.&nbsp; See the note in Storage commands regarding malformed</p>

<p>requests.</p>

<p>The response will be one of:</p>

<ul>
<li><p>&#8220;NOT_FOUND\r\n&#8221; to indicate the item with this value was not found</p></li>
<li><p><value>\r\n , where <value> is the new value of the item&#8217;s data,</p></li>
</ul>


<p>after the increment/decrement operation was carried out.</p>

<p>Note that underflow in the &#8220;decr&#8221; command is caught: if a client tries</p>

<p>to decrease the value below 0, the new value will be 0.&nbsp; Overflow in</p>

<p>the &#8220;incr&#8221; command will wrap around the 64 bit mark.</p>

<p>Note also that decrementing a number such that it loses length isn&#8217;t</p>

<p>guaranteed to decrement its returned length.&nbsp; The number MAY be</p>

<p>space-padded at the end, but this is purely an implementation</p>

<p>optimization, so you also shouldn&#8217;t rely on that.</p>

<p>Statistics</p>

<hr />

<p>The command &#8220;stats&#8221; is used to query the server about statistics it</p>

<p>maintains and other internal data. It has two forms. Without</p>

<p>arguments:</p>

<p>stats\r\n</p>

<p>it causes the server to output general-purpose statistics and</p>

<p>settings, documented below.&nbsp; In the other form it has some arguments:</p>

<p>stats <args>\r\n</p>

<p>Depending on <args>, various internal data is sent by the server. The</p>

<p>kinds of arguments and the data sent are not documented in this vesion</p>

<p>of the protocol, and are subject to change for the convenience of</p>

<p>memcache developers.</p>

<p>General-purpose statistics</p>

<hr />

<p>Upon receiving the &#8220;stats&#8221; command without arguments, the server sents</p>

<p>a number of lines which look like this:</p>

<p>STAT <name> <value>\r\n</p>

<p>The server terminates this list with the line</p>

<p>END\r\n</p>

<p>In each line of statistics, <name> is the name of this statistic, and</p>

<p><value> is the data.&nbsp; The following is the list of all names sent in</p>

<p>response to the &#8220;stats&#8221; command, together with the type of the value</p>

<p>sent for this name, and the meaning of the value.</p>

<p>In the type column below, &#8220;32u&#8221; means a 32-bit unsigned integer, &#8220;64u&#8221;</p>

<p>means a 64-bit unsigner integer. &#8216;32u:32u&#8217; means two 32-but unsigned</p>

<p>integers separated by a colon.</p>

<p>Name&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Type &nbsp; &nbsp; Meaning</p>

<hr />

<p>pid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 32u&nbsp; &nbsp; &nbsp; Process id of this server process</p>

<p>uptime&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 32u&nbsp; &nbsp; &nbsp; Number of seconds this server has been running</p>

<p>time&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 32u&nbsp; &nbsp; &nbsp; current UNIX time according to the server</p>

<p>version &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string &nbsp; Version string of this server</p>

<p>pointer_size&nbsp; &nbsp; &nbsp; 32 &nbsp; &nbsp; &nbsp; Default size of pointers on the host OS</p>

<p>(generally 32 or 64)</p>

<p>rusage_user &nbsp; &nbsp; &nbsp; 32u:32u&nbsp; Accumulated user time for this process</p>

<p>(seconds:microseconds)</p>

<p>rusage_system &nbsp; &nbsp; 32u:32u&nbsp; Accumulated system time for this process</p>

<p>(seconds:microseconds)</p>

<p>curr_items&nbsp; &nbsp; &nbsp; &nbsp; 32u&nbsp; &nbsp; &nbsp; Current number of items stored by the server</p>

<p>total_items &nbsp; &nbsp; &nbsp; 32u&nbsp; &nbsp; &nbsp; Total number of items stored by this server</p>

<p>ever since it started</p>

<p>bytes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64u&nbsp; &nbsp; &nbsp; Current number of bytes used by this server</p>

<p>to store items</p>

<p>curr_connections&nbsp; 32u&nbsp; &nbsp; &nbsp; Number of open connections</p>

<p>total_connections 32u&nbsp; &nbsp; &nbsp; Total number of connections opened since</p>

<p>the server started running</p>

<p>connection_structures 32u&nbsp; Number of connection structures allocated</p>

<p>by the server</p>

<p>cmd_get &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64u&nbsp; &nbsp; &nbsp; Cumulative number of retrieval requests</p>

<p>cmd_set &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64u&nbsp; &nbsp; &nbsp; Cumulative number of storage requests</p>

<p>get_hits&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64u&nbsp; &nbsp; &nbsp; Number of keys that have been requested and</p>

<p>found present</p>

<p>get_misses&nbsp; &nbsp; &nbsp; &nbsp; 64u&nbsp; &nbsp; &nbsp; Number of items that have been requested</p>

<p>and not found</p>

<p>evictions &nbsp; &nbsp; &nbsp; &nbsp; 64u&nbsp; &nbsp; &nbsp; Number of valid items removed from cache</p>

<p>to free memory for new items</p>

<p>bytes_read&nbsp; &nbsp; &nbsp; &nbsp; 64u&nbsp; &nbsp; &nbsp; Total number of bytes read by this server</p>

<p>from network</p>

<p>bytes_written &nbsp; &nbsp; 64u&nbsp; &nbsp; &nbsp; Total number of bytes sent by this server to</p>

<p>network</p>

<p>limit_maxbytes&nbsp; &nbsp; 32u&nbsp; &nbsp; &nbsp; Number of bytes this server is allowed to</p>

<p>use for storage.</p>

<p>threads &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 32u&nbsp; &nbsp; &nbsp; Number of worker threads requested.</p>

<p>(see doc/threads.txt)</p>

<p>Item statistics</p>

<hr />

<p>CAVEAT: This section describes statistics which are subject to change in the</p>

<p>future.</p>

<p>The &#8220;stats&#8221; command with the argument of &#8220;items&#8221; returns information about</p>

<p>item storage per slab class. The data is returned in the format:</p>

<p>STAT items:<slabclass>:<stat> <value>\r\n</p>

<p>The server terminates this list with the line</p>

<p>END\r\n</p>

<p>The slabclass aligns with class ids used by the &#8220;stats slabs&#8221; command. Where</p>

<p>&#8220;stats slabs&#8221; describes size and memory usage, &#8220;stats items&#8221; shows higher</p>

<p>level information.</p>

<p>The following item values are defined as of writing.</p>

<p>Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning</p>

<hr />

<p>number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Number of items presently stored in this class. Expired</p>

<p>items are not automatically excluded.</p>

<p>age&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Age of the oldest item in the LRU.</p>

<p>evicted&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Number of times an item had to be evicted from the LRU</p>

<p>before it expired.</p>

<p>outofmemory&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Number of times the underlying slab class was unable to</p>

<p>store a new item. This means you are running with -M or</p>

<p>an eviction failed.</p>

<p>Note this will only display information about slabs which exist, so an empty</p>

<p>cache will return an empty set.</p>

<p>Item size statistics</p>

<hr />

<p>CAVEAT: This section describes statistics which are subject to change in the</p>

<p>future.</p>

<p>The &#8220;stats&#8221; command with the argument of &#8220;sizes&#8221; returns information about the</p>

<p>general size and count of all items stored in the cache.</p>

<p>WARNING: This command WILL lock up your cache! It iterates over <em>every item</em></p>

<p>and examines the size. While the operation is fast, if you have many items</p>

<p>you could prevent memcached from serving requests for several seconds.</p>

<p>The data is returned in the following format:</p>

<p><size> <count>\r\n</p>

<p>The server terminates this list with the line</p>

<p>END\r\n</p>

<p>&#8216;size&#8217; is an approximate size of the item, within 32 bytes.</p>

<p>&#8216;count&#8217; is the amount of items that exist within that 32-byte range.</p>

<p>This is essentially a display of all of your items if there was a slab class</p>

<p>for every 32 bytes. You can use this to determine if adjusting the slab growth</p>

<p>factor would save memory overhead. For example: generating more classes in the</p>

<p>lower range could allow items to fit more snugly into their slab classes, if</p>

<p>most of your items are less than 200 bytes in size.</p>

<p>Slab statistics</p>

<hr />

<p>CAVEAT: This section describes statistics which are subject to change in the</p>

<p>future.</p>

<p>The &#8220;stats&#8221; command with the argument of &#8220;slabs&#8221; returns information about</p>

<p>each of the slabs created by memcached during runtime. This includes per-slab</p>

<p>information along with some totals. The data is returned in the format:</p>

<p>STAT <slabclass>:<stat> <value>\r\n</p>

<p>STAT <stat> <value>\r\n</p>

<p>The server terminates this list with the line</p>

<p>END\r\n</p>

<p>Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning</p>

<hr />

<p>chunk_size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The amount of space each chunk uses. One item will use</p>

<p>one chunk of the appropriate size.</p>

<p>chunks_per_page&nbsp; &nbsp; &nbsp; &nbsp; How many chunks exist within one page. A page by</p>

<p>default is one megabyte in size. Slabs are allocated per</p>

<p>page, then broken into chunks.</p>

<p>total_pages&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Total number of pages allocated to the slab class.</p>

<p>total_chunks &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Total number of chunks allocated to the slab class.</p>

<p>used_chunks&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; How many chunks have been allocated to items.</p>

<p>free_chunks&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Chunks not yet allocated to items, or freed via delete.</p>

<p>free_chunks_end&nbsp; &nbsp; &nbsp; &nbsp; Number of free chunks at the end of the last allocated</p>

<p>page.</p>

<p>active_slabs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Total number of slab classes allocated.</p>

<p>total_malloced &nbsp; &nbsp; &nbsp; &nbsp; Total amount of memory allocated to slab pages.</p>

<p>Other commands</p>

<hr />

<p>&#8220;flush_all&#8221; is a command with an optional numeric argument. It always</p>

<p>succeeds, and the server sends &#8220;OK\r\n&#8221; in response (unless &#8220;noreply&#8221;</p>

<p>is given as the last parameter). Its effect is to invalidate all</p>

<p>existing items immediately (by default) or after the expiration</p>

<p>specified.&nbsp; After invalidation none of the items will be returned in</p>

<p>response to a retrieval command (unless it&#8217;s stored again under the</p>

<p>same key <em>after</em> flush_all has invalidated the items). flush_all</p>

<p>doesn&#8217;t actually free all the memory taken up by existing items; that</p>

<p>will happen gradually as new items are stored. The most precise</p>

<p>definition of what flush_all does is the following: it causes all</p>

<p>items whose update time is earlier than the time at which flush_all</p>

<p>was set to be executed to be ignored for retrieval purposes.</p>

<p>The intent of flush_all with a delay, was that in a setting where you</p>

<p>have a pool of memcached servers, and you need to flush all content,</p>

<p>you have the option of not resetting all memcached servers at the</p>

<p>same time (which could e.g. cause a spike in database load with all</p>

<p>clients suddenly needing to recreate content that would otherwise</p>

<p>have been found in the memcached daemon).</p>

<p>The delay option allows you to have them reset in e.g. 10 second</p>

<p>intervals (by passing 0 to the first, 10 to the second, 20 to the</p>

<p>third, etc. etc.).</p>

<p>&#8220;version&#8221; is a command with no arguments:</p>

<p>version\r\n</p>

<p>In response, the server sends&nbsp;&#8220;VERSION <version>\r\n&#8221;, where <version> is the version string for the</p>

<p>server.</p>

<p>&#8220;verbosity&#8221; is a command with a numeric argument. It always succeeds,</p>

<p>and the server sends &#8220;OK\r\n&#8221; in response (unless &#8220;noreply&#8221; is given</p>

<p>as the last parameter). Its effect is to set the verbosity level of</p>

<p>the logging output.</p>

<p>&#8220;quit&#8221; is a command with no arguments:</p>

<p>quit\r\n</p>

<p>Upon receiving this command, the server closes the</p>

<p>connection. However, the client may also simply close the connection</p>

<p>when it no longer needs it, without issuing this command.</p>

<p>UDP protocol</p>

<hr />

<p>For very large installations where the number of clients is high enough</p>

<p>that the number of TCP connections causes scaling difficulties, there is</p>

<p>also a UDP-based interface. The UDP interface does not provide guaranteed</p>

<p>delivery, so should only be used for operations that aren&#8217;t required to</p>

<p>succeed; typically it is used for &#8220;get&#8221; requests where a missing or</p>

<p>incomplete response can simply be treated as a cache miss.</p>

<p>Each UDP datagram contains a simple frame header, followed by data in the</p>

<p>same format as the TCP protocol described above. In the current</p>

<p>implementation, requests must be contained in a single UDP datagram, but</p>

<p>responses may span several datagrams. (The only common requests that would</p>

<p>span multiple datagrams are huge multi-key &#8220;get&#8221; requests and &#8220;set&#8221;</p>

<p>requests, both of which are more suitable to TCP transport for reliability</p>

<p>reasons anyway.)</p>

<p>The frame header is 8 bytes long, as follows (all values are 16-bit integers</p>

<p>in network byte order, high byte first):</p>

<p>0-1 Request ID</p>

<p>2-3 Sequence number</p>

<p>4-5 Total number of datagrams in this message</p>

<p>6-7 Reserved for future use; must be 0</p>

<p>The request ID is supplied by the client. Typically it will be a</p>

<p>monotonically increasing value starting from a random seed, but the client</p>

<p>is free to use whatever request IDs it likes. The server&#8217;s response will</p>

<p>contain the same ID as the incoming request. The client uses the request ID</p>

<p>to differentiate between responses to outstanding requests if there are</p>

<p>several pending from the same server; any datagrams with an unknown request</p>

<p>ID are probably delayed responses to an earlier request and should be</p>

<p>discarded.</p>

<p>The sequence number ranges from 0 to n-1, where n is the total number of</p>

<p>datagrams in the message. The client should concatenate the payloads of the</p>

<p>datagrams for a given response in sequence number order; the resulting byte</p>

<p>stream will contain a complete response in the same format as the TCP</p>

<p>protocol (including terminating \r\n sequences).</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/13/%E5%93%8E%EF%BC%8C%E4%BA%BA%E7%94%9F%EF%BC%9B%E5%93%8E%EF%BC%8C%E4%BA%A7%E5%93%81/">哎，人生；哎，产品</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-13T02:55:44+08:00" pubdate data-updated="true">2011-11-13</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前段时间由于项目上面的业务变更，导致memcacheq这个消息队列使用有点捉襟见肘。由于其对于消息体大小有限制，而且最大不能超过60K，就萌生了自己写一个消息队列的想法。总是掌握在自己手中，能应对现有的业务需要的东西用着才爽啊。本来计划是有空就改写的，但是由于产品上面一而再再而三的修改功能、修改方向，最坑爹的事情是没有功能定义的情况下得去照搬别的产品的功能。悲剧ing。于是这个计划一直没有实施。</p>

<p>哎，技术架构方案的选择真得是件麻烦的事情，得遇见今后一段时间的业务变更与增长，又要考虑现有资源。这样做出合理的，可以实现的方案。我们那架构师也辛苦，总得和老板设计的产品做pk。心力交瘁啊。有时候想想，也迷茫，咱这是做了啥东西？用来干啥？对自己也没多大帮助啊？更坑爹的事情是，把外包那套管理项目的方式折腾过来，每天都是下班时过来给你折腾点东西，杯具ing。产品设计上面没有明确的功能性设计，只是笼统的说，我要这个功能，其他你可以去参考别人怎么做的。你妹啊！</p>

<p>一个ui图，再加个说明，给你，你去设计接口吧。好吧，设计完接口又说，你这样不行，客户端没法调用的，两个接口，怎么可以这样子用，客户端调用很麻烦的，你如果做客户端，你怎么去弄？哎，坑爹啊！</p>

<p>神马浮云啊，没做过产品经理的，把项目管理那套东西搬过来，好吧，你行的。我算是清楚了。我只写代码。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/11/%E5%9D%91%E7%88%B9%E7%9A%84%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/">坑爹的产品设计</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-11T00:30:52+08:00" pubdate data-updated="true">2011-11-11</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>坑爹的产品设计会造成神马后果，哎，我总算见识了。从没见过时间被扣的这么死的，好吧，你是老板，我认了。也不想想，万一有啥问题要查，要调试，这不还是被打断？</p>

<p>搞项目的，以为看了些别人的产品就来折腾产品设计，好吧，你牛。这么好的一个产品经理摆在那里，不要，成，那你自己弄出点好的事情来啊？一要个功能，就来，你看看别人怎么做的么，你看过么？没吧？那你去看看然后给出一个解决方案来吧？行不？什么时间可以有？明天？</p>

<p>坑爹啊，我一个搞技术的人给你去折腾功能设计方案，你妹啊！一会要查这个问题，一会要做这个事情，我又不是神。行吧行吧，总会有个解决方法的。打工的，我忍了。看吧，看别人怎么做的呗。</p>

<p>好吧，你只要有这个功能，功能怎么样的，你不管。成啊，最后呢？还不是需要实现去改？来回折腾累不累啊？硬要短时间内完成，行啊，那你别介意有什么意外问题啊。又要没有别的问题，又要快、好的实现，但是你有好好的去设计这个功能么？还不就是画了一下uiflow？能解决问题么？坑爹啊！</p>

<p>哎，看别人有的功能，你也想加，ok，可以，你得想想我们这个产品用来做啥的吧？迷茫啊，用来做啥都不知道，亮点呢？好的产品一般都是功能简单，但是都是必须的功能，而且都是能抓住用户粘度的功能。我们呢？有想过么？用户的粘度？</p>

<p>这个总得好好考虑吧？行，我一个码农，不知道说啥，嘿，你说干啥就干啥呗，反正也讲不通，就这样吧！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/08/%E5%90%90%E5%90%90%E6%A7%BD/">吐吐槽</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-08T02:13:54+08:00" pubdate data-updated="true">2011-11-08</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>近来很不顺，工作上面，不爽。很多问题总是来回的折腾。好吧，产品入口没有设计好，想用技术手段去解决后续的问题？这不是坑爹是什么？我们做的东西，自己不用，为啥？就单纯用来发发消息？做测试啊，你以为呢？</p>

<p>产品的应用场景有概念么？这东西用来干啥的？那些是用户？那些是潜在用户？目标性有么？为啥我不用啊，我拿你这东西就给别人发发消息，我直接打电话不就得了。做产品，一味的看别人做了那些，嗯，好，我也加上去，可以啊。关键是你做的是什么产品啊？四不像啊？</p>

<p>功能功能，坑爹的功能。东西做简单点，是王道啊。为啥一上来说了一个功能，就着急着实现？后来出现一些问题，还不是靠测试来找？要是把功能定义、流程、影响、其他附属内容啥的都考虑全了，还需要那么多测试么？</p>

<p>互联网公司怎么不能在上班时玩游戏？怎么不能闲聊？怎么不能干啥干啥啦？悲剧的人生啊。看着人家休息，玩玩心里就不舒服，还干啥啊？搞飞机去算了。</p>

<p>完全木有氛围，人是不错，但是氛围么，哎。。。</p>

<p>现在就开始拿着人当枪使了，悲崔的我啊，搞政治咯。算啦吧，歇歇吧。都是狗屁，都歇歇啦！</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/4/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
	<a href="/blog/about/">About Me</a>
    
    <a class="next" href="/blog/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/12/13/%E7%A2%8E%E7%A2%8E%E5%BF%B5/">碎碎念</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/14/redis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%28%E4%BA%8C%29/">redis源码学习记录(二)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/09/22/%E4%B9%9D%E6%9C%88%E6%9D%82%E5%BF%B5/">九月杂念</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/09/19/redis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">redis源码学习记录</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/04/07/%E5%85%B3%E4%BA%8E%E6%96%B0%E5%85%AC%E5%8F%B8/">关于新公司</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Links</h1>
  <ul id="recent_posts">
      <li class="post">
        <a href="http://hmfly.info/">GeoVisual(GIS读研南)</a>
      </li>
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/kurten">@kurten</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'kurten',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - kurten -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
